---
title: "analyseAll"
author: "Alex Holcombe"
date: "7/28/2018"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(plyr) #need to load because need it for Rmisc, and recommended load it before dplyr
library(dplyr)
```

FIRST RUN demographicsAndExclusions.Rmd

Load ggplot and dplyr
```{r j, echo=FALSE}
library(ggplot2)
library(dplyr)

tb<- tb %>% mutate(leftTopBias = case_when(spatial == "horiz" ~ correct0 - correct1,
                                          spatial == "vert" ~ correct1 - correct0,   
                                          TRUE ~ as.integer(-99)   )) #else, but this shouldn't occur

tb<- tb %>% mutate(canonical = ori==0) 

```

## Proportion correct

One target.
Why when rightResponseFirst == True, almost always scored as incorrect, correct0 = 0? (indicating subject got it wrong?). Probably didn't match the response0 to the correct stimulus, instead still matched it to the  letter on the left/top. And unfortunately didn't record the letter/word on the other side. To fix, have to write python script to rerun the code with the same seed to find out what letters they were, and then integrate with my tibble. Jesus.

```{r k, echo=FALSE}
#Look at one-target performance
tbOne <- tb %>% filter(oneTarget == "True") 
#correct0 refers to left, correct1 to right.
#But for one-target trials, rightResponseFirst is the only thing that tells you which side it was on.
eachCorrOne<- tbOne %>% group_by(rightResponseFirst) %>% summarise_at(c("correct0","correct1"),mean)
print(eachCorrOne)
```

Two targets

```{r Overall average correct, echo=FALSE}
#Exclude trials with one target, three targets
tbTwo <- tb %>% filter(oneTarget == "False", numSimultaneousStim < 3) 
#correct0 refers to left, correct1 to right.
eachCorrect<- tbTwo %>% summarise_at(c("correct0","correct1"),mean)
print(eachCorrect)
avgCorrect = rowMeans(eachCorrect)
```

```{r inspectStaircase}

#Inspect what ISIframes got up to

maxPossibleISIframes <- 9
maxEachSubject<- tb %>% filter(practice==0) %>% group_by(subject) %>% summarise(maxISI = max(ISIframes))
#Determine subject numbers who maxxed out
maxedOut <- unique(  tb %>% filter(ISIframes == maxPossibleISIframes)   )
ggplot(maxEachSubject, aes(x=maxISI)) + geom_histogram(binwidth=.5) +scale_x_continuous(breaks=seq(2,9))
```


```{r Exclude}
#Exclusion criteria
correctExclusionThreshold <- .4
#Exclude trials with one target, three targets
tbTwo <- tb %>% filter(oneTarget == "False", numSimultaneousStim < 3) 
#correct0 refers to left, correct1 to right.
overall<- tbTwo %>% group_by(subject) %>% summarise_at(c("correct0","correct1"),mean)
overall <- overall %>% mutate(pCorr = (correct0 + correct1)/2)
tooLow2 <- overall %>% filter(pCorr < correctExclusionThreshold)
cat("subjects who were too low in two-target condition are:")
tooLow2

#Exclude low performers in the 3-target condition
tbThree <- tb %>% filter(numSimultaneousStim == 3) 
overall<- tbThree %>% group_by(subject) %>% summarise_at(c("correct0","correct1","correct2"),mean)
overall <- overall %>% mutate(pCorr = (correct0 + correct1 + correct2)/3)
tooLow3 <- overall %>% filter(pCorr < correctExclusionThreshold)
cat("subjects who were too low in three-target condition are:")
tooLow3

```

```{r Calculate how many swaps each subject has}

#Compare response0 to 
#
```

```{r plotEach}
#Group by condition, which is defined by spatial,stimType,flipped,orient
#table(tbTwo$spatial,tbTwo$flipped,tbTwo$ori,tbTwo$stimType)
#Then plot difference between correct0 and correct1. One way to get difference is subtract correct1 from correct0 and average
#tbTwo$leftBtmBias <- tbTwo$correct0-tbTwo$correct1


tbTwo <- tbTwo %>% mutate(flippedTemp = substr(flipped,1,1)) #reduce to first letter only
tbTwo <- tbTwo %>% mutate(cond = paste(stimType, spatial, ori, flipped, sep = '_'))
tbTwo <- tbTwo %>% mutate(condExceptStim = paste(spatial, ori, flippedTemp, sep = '_'))
gg<- ggplot(tbTwo, aes(x=condExceptStim,y=leftTopBias)) + stat_summary(fun.y="mean",geom="point",size=2, alpha=.5) + facet_grid(stimType~.)
gg<- gg+ stat_summary(fun.data="mean_cl_boot",fun.args=list(conf.int=0.95),geom="errorbar",width=.3,size=1) 
show(gg)
```

```{r wordsByCond}
wordsByS <- tbTwo %>% filter(stimType=="word") %>% group_by(subject,spatial) %>% summarise_at(c("correct0","correct1"),mean)
wordsByCond<- wordsByS %>% group_by(spatial)  %>% summarise_all(mean)
wordsByCond
```
Thus ,for Caleb:
When participants saw (3 letter words) words oriented left to right the accuracy for the left word was 65.7% and the accuracy for the right word was 70.6%.

When participants saw (3 letter words) words oriented left to right (but presented top and bottom) the accuracy for the top word was 71.0% and the accuracy for the bottom word was 37.6%.

```{r nicerPlot}
ltrs2 <- tbTwo %>% filter(stimType=="letter")
# gg<- ggplot(ltrs2, aes(x=condExceptStim,y=leftTopBias)) + stat_summary(fun.y="mean",geom="point",size=2, alpha=.5) + facet_grid(.~canonical)
# gg<- gg+ stat_summary(fun.data="mean_cl_boot",fun.args=list(conf.int=0.95),geom="errorbar",width=.3,size=1) 
# show(gg)

ltrs2<- ltrs2 %>% mutate(cond = case_when(condExceptStim == "vert_-90_F" ~ "facing up",
                                        condExceptStim == "vert_90_F" ~ "facing down", 
                                        condExceptStim == "vert_0_F" ~ "facing right",
                                          TRUE ~ "unknown"   )) #e
# gg<- ggplot(rotated, aes(x=condExceptStim,y=leftTopBias)) + stat_summary(fun.y="mean",geom="point",size=2, alpha=.5) + stat_summary(fun.data="mean_cl_boot",fun.args=list(conf.int=0.95),geom="errorbar",width=.3,size=1) 
# show(gg)


vert<- ltrs2 %>% filter(spatial=="vert")
papaja::apa_beeplot(data=vert, id="subject", dv="leftTopBias", factors="cond",
                    ylab = "upper - lower (proportion correct)", xlab = "orientation",
                    args_points = list(cex = 1, bg = c("black"),col="black"),
                    args_swarm = list(cex = .3, bg = c("white"),col="grey50"),
                    , args_error_bars = list(lwd=2.2,length = 0.13))
abline(h=0)

#apa_print() output looks horrible unless knit into PDF or Word as part of a papaja document
#papaja::apa_print(t_vert)

```
Above the effect of the orientation manipulation was pretty big, but the baseline bias (upper bias) is bigger than the left bias seen in the other plot.

```{r horizPlots}
rotated <- ltrs2 %>% filter(canonical==FALSE)
papaja::apa_beeplot(data=rotated, id="subject", dv="leftTopBias", factors="cond",
                    ylab = "upper - lower (proportion correct)", xlab = "orientation",
                    args_points = list(cex = 1, bg = c("black"),col="black"),
                    args_swarm = list(cex = .3, bg = c("white"),col="grey50"),
                    , args_error_bars = list(lwd=2.2,length = 0.13))
abline(h=0)
horiz <- ltrs2 %>% filter(spatial=="horiz")
horiz<- horiz %>% mutate(cond = case_when(condExceptStim == "horiz_0_F" ~ "normal",
                                        condExceptStim == "horiz_0_T" ~ "mirror-reversed",   
                                          TRUE ~ "unknown"   )) 
#change order so normal appears first on plot
horiz$cond <- as.factor(horiz$cond)
horiz <- transform(horiz, cond=reorder(cond, flipped) )  #https://stackoverflow.com/a/3744432/302378
papaja::apa_beeplot(data=horiz, id="subject", dv="leftTopBias", factors="cond",
                    ylab = "left - right (proportion correct)", xlab = "orientation",
                    args_points = list(cex = 1, bg = c("black"),col="black"),
                    args_swarm = list(cex = .3, bg = c("white"),col="grey50"),
                    , args_error_bars = list(lwd=2.2,length = 0.13))
abline(h=0)
```

The horizontal t-test results are
```{r ttestHoriz}
t_horiz <- t.test(
  x = (horiz %>% filter(cond == "normal"))$leftTopBias
  , y = (horiz %>% filter(cond == "mirror-reversed"))$leftTopBias
  , paired = FALSE
)

t_horiz
# Let's see what the apa_print() output looks like
#papaja::apa_print(t_horiz)
```

For horizontal configuration, the normal and mirror-reversed orientation results with upper and lower confidence intervals are:
```{r}
#install.packages("Rmisc")
library(Rmisc)
horiz %>% group_by(cond) %>% summarise(upperCI = CI(leftTopBias)[1], mean=mean(leftTopBias), lower= CI(leftTopBias)[3])
```

For Caleb PSYC1, calculate accuracy per condition, not just bias
```{r}
horizEachS<- horiz %>% group_by(cond,subject) %>% summarise_at(.vars = c("correct0","correct1"),
                 .funs = c(mean="mean"))
horizEachCond<- horizEachS %>%  group_by(cond) %>% summarise_all(funs(mean))
````

```{r}
vertEachS<- vert %>% group_by(cond,subject) %>% summarise_at(.vars = c("correct0","correct1"),
                 .funs = c(mean="mean"))
vertEachCond<- vertEachS %>%  group_by(cond) %>% summarise_all(funs(mean))
````


```{r horizCondTtest}

t_horiz <- t.test(
  x = (horizEachS %>% filter(cond == "mirror-reversed"))$correct0_mean
  , y = (horiz %>% filter(cond == "mirror-reversed"))$correct1_mean
  , paired = FALSE
)
t_horiz
```

```{r ttestVert}
t_vert <- t.test(
  x = (vert %>% filter(cond == "facing down"))$leftTopBias
  , y = (vert %>% filter(cond == "facing up"))$leftTopBias
  , paired = FALSE
)
t_vert
```

```{r confidenceIntervalsVert}
vert %>% group_by(cond) %>% summarise(upperCI = CI(leftTopBias)[1], mean=mean(leftTopBias), lower= CI(leftTopBias)[3])
```

Correlate the bias of each participant with their author score.
```{r correlate}
#install.packages('ggstatsplot')  #doesn't work
#Probably need to reduce the dataframe to one data point per subject
tbTwoSumm <- tbTwo %>% group_by(subject) %>% summarise_at(c("leftTopBias", "authorsPct", "authorsRaw", "authorsTotalChosen"),mean)
hh<- ggplot(tbTwoSumm, aes(y=leftTopBias, x=authorsPct)) + geom_point() +   geom_smooth(method="lm",se=FALSE) +
  geom_point() 

lm_eqn = function(m) {

  l <- list(a = format(coef(m)[1], digits = 2),
      b = format(abs(coef(m)[2]), digits = 2),
      r2 = format(summary(m)$r.squared, digits = 3));

  if (coef(m)[2] >= 0)  {
    eq <- substitute(italic(y) == a + b %.% italic(x)*","~~italic(r)^2~"="~r2,l)
  } else {
    eq <- substitute(italic(y) == a - b %.% italic(x)*","~~italic(r)^2~"="~r2,l)    
  }

  as.character(as.expression(eq));                 
}
hh = hh + geom_text(aes(x = .3, y = .64, label = lm_eqn(lm(leftTopBias ~ authorsPct, tbTwoSumm))), parse = TRUE)
hh
#cor.test(
```
change MEAN ABOVE TO INCLUDE FIRST LANGUAGE READ AND TAKES FIRST INSTNACE IF NOT NUMERIC
Look at first language read.
```